<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mutilated Chessboard | WMC Math Club</title>
  <link rel="stylesheet" href="style.css">
  <style>
    .board{
        width: calc(min(70vw,400px));
        height: calc(min(70vw,400px));
        display: grid;
        grid-template-columns: auto auto auto auto auto auto auto auto;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%,-50%);
        user-select:none;
    }

    .square{
        border:1px solid #111;
        display:flex;
        z-index:1
    }

    .light{
        background: #0077ff;
    }
    .dark{
        background: #333333;
    }
    .non-existant{
        visibility: hidden;
    }

    .domino {
        background: #0cb600;
        border:3px solid #111;
        display: flex;
        z-index: 2;
        position: absolute;
        user-select:none;
    }

    .vertical {
        width: calc(min(70vw,400px)/8 - 5px);
        height: calc(min(70vw,400px)/4 - 5px);
        left: 85%;
        top: 30%;
    }

    .horizontal {
        width: calc(min(70vw,400px)/4 - 5px);
        height: calc(min(70vw,400px)/8 - 5px);
        left: 85%;
        top: 70%;
    }

    @media (max-width: 768px) {
      .board {
        top: 5%;
        transform: translate(-50%,0);
      }
      .vertical {
        left: 30%;
        top: 90%;
      }
      .horizontal {
        left: 70%;
        top: 90%;
      }
    }
  </style>
</head>
<body>
  <div class="card" style="position: absolute; top: 0">
    <h1>Cover the chessboard with dominoes.</h1>
    <p class="lead">Add 31 dominoes to the mutilated chessboard, completely covering it.</p>

    <div class="play">
      <div id="playArea" class="play-area" aria-label="puzzle area">
        <div class="board" id="board"></div>
        <div class="vertical domino" data-orient="vertical"></div>
        <div class="horizontal domino" data-orient="horizontal"></div>
      </div>
      
      <script>
          for(let i = 0; i<8; ++i) {
              for(let j = 0; j<8; ++j) {
                  const square = document.createElement('div');
                  square.className = 'square';
                  if((i===0 && j===0) || (i===7 && j===7)) {
                      square.classList.add('non-existant');
                  } else {
                      square.classList.add((i+j)%2 ? 'light':'dark');
                  }
                  document.getElementById('board').appendChild(square);
              }
          }

          const area = document.getElementById("playArea").getBoundingClientRect();
          const selections = Array.from(document.querySelectorAll('.domino'));
          for(const el of selections) {
            const box = el.getBoundingClientRect();
            el.style.left = box.left-area.left-box.width/2 + 'px';
            el.style.top = box.top-area.top-box.height/2 + 'px';
          }
      </script>

      <div class="controls">
        <button id="undo">Undo</button>
        <button id="clear">Clear</button>
        <button id="check" style="background: #118b2f">Check</button>
      </div>
      <div class="status" id="status">Place dominoes on the chessboard.</div>
    </div>

    <div class="footbar">
      <div style="background:#ededed;padding:12px;border-radius:8px">
        <button id="sol_reveal">Click to reveal solution</button>
        <div id="solution" style="visibility: hidden; height: 0;">
          <h3>Solution</h3>
          <p>After struggling with this problem for a while, it may seem like it's impossible. If you thought that, you were right, because there is <b>no arrangement</b> of dominoes that covers this chessboard. However, instead of giving up, we should try to <b>prove</b> that no arrangement works.</p>
          <p>Obviously, there are far too many different arrangements to try them all, so we'll have to be smarter. A good place to start would be to try some arrangements and see what fails.</p>
          <img src="mutilated-chessboard-sol-1.png" style="width: 30%; display: inline-block;">
          <img src="mutilated-chessboard-sol-2.png" style="width: 30%; display: inline-block;">
          <img src="mutilated-chessboard-sol-3.png" style="width: 30%; display: inline-block;">
          <p>Something you may notice is that after 30 dominoes are placed, there are always two blue squares left. So, let's analyze the colours on the chessboard a bit closer.</p>
          <img src="mutilated-chessboard-sol-4.png" style="width: 50%; display: block; margin: auto;">
          <p>Notice that no matter how we place a domino, it always covers one blue square and one black square. Therefore, any way we place 31 non-overlapping dominoes will cover 31 blue squares and 31 black squares.</p>
          <p>However, both the squares that were removed from the chessboard were black, meaning that it has 32 blue squares and 30 black squares left, so it cannot be covered by 31 non-overlapping dominoes.</p>
        </div>
        <script>
          document.getElementById('sol_reveal').onclick = function(){
            const sol = document.getElementById('solution');
            sol.style.visibility = (sol.style.visibility==='visible' ? 'hidden' : 'visible');
            sol.style.height = (sol.style.visibility==='visible' ? 'auto' : '0');
            this.textContent = (sol.style.visibility==='visible' ? 'Hide solution' : 'Click to reveal solution');
          };
        </script>
        <h3>More puzzles & resources</h3>
        <p>Click below for more problems like this and math resources (Google Classroom).</p>
        <a id="moreLink" class="link" href="#">Click here for more problems like this / math resources</a>
        <button id="copyLink" style="margin-top:8px">Copy link</button>
      </div>
    </div>
  </div>

  <script>

    // DOM
    const board = document.getElementById("board");
    const dominoes = Array.from(document.querySelectorAll('.domino'));
    const playArea = document.getElementById('playArea');
    const status = document.getElementById('status');

    let active = null; // {domino, orientation, relative X, relative Y, pos}
    let covered = Array(8).fill().map(()=>Array(8).fill(false));
    let added = [];

    function startDominoDrag(domino, clientX, clientY, nw){
      const orientation = domino.dataset.orient;
      const d = domino.getBoundingClientRect();
      const b = board.getBoundingClientRect();
      const x = clientX-d.left; const y = clientY-d.top;
      const oldCol = (nw?-1:Math.round(8*(d.left-b.left)/b.width));
      const oldRow = (nw?-1:Math.round(8*(d.top-b.top)/b.height));
      let newDomino;
      if(nw)
        newDomino = domino.cloneNode(true);
      else
        newDomino = domino;
      active = {
        domino: newDomino,
        orientation: orientation,
        rx: x, ry: y,
        posr: -1, posc: -1,
        oldr: oldRow, oldc: oldCol
      };
      
      if(nw) {
        document.getElementById("playArea").appendChild(newDomino);
      } else {
        covered[oldRow][oldCol] = false;
        covered[oldRow + (orientation=='vertical')][oldCol+(orientation=='horizontal')] = false;
      }

      newDomino.style.zIndex = 3;

      function onMove(ev){
        const clientX = ev.clientX !== undefined ? ev.clientX : (ev.touches && ev.touches[0].clientX);
        const clientY = ev.clientY !== undefined ? ev.clientY : (ev.touches && ev.touches[0].clientY);
        const left = clientX-active.rx; const top = clientY-active.ry;

        const b = board.getBoundingClientRect();
        const playRect = playArea.getBoundingClientRect();

        // if statements are kinda redundant but idc
        if(left >= b.left-b.width/16 && left <= b.right && top >= b.top-b.height/16 && top <= b.bottom) {
          let col = Math.min(7,Math.floor((left+b.width/16-b.left)/b.width*8));
          let row = Math.min(7,Math.floor((top+b.height/16-b.top)/b.height*8));
          const dcol = (active.orientation == 'horizontal');
          const drow = (active.orientation == 'vertical');

          if(row==0 && col==0 || row==7 && col==7 || row+drow>7 || col+dcol>7 || row+drow==7 && col+dcol==7) {
            active.domino.style.left = left - playRect.left + 'px';
            active.domino.style.top = top - playRect.top + 'px';
            active.posr = -1; active.posc = -1;
            active.domino.style.borderColor = '#111';
          } else {
            if(covered[row][col] || covered[row+drow][col+dcol]) {
              active.domino.style.borderColor = 'red';
            } else {
              active.domino.style.borderColor = '#111';
            }
            active.domino.style.left = col*b.width/8 + b.left - playRect.left-6 + 'px';
            active.domino.style.top = row*b.height/8 + b.top - playRect.top-6 + 'px';
            active.posr = row; active.posc = col;
          }
        } else {
          active.domino.style.left = left - playRect.left + 'px';
          active.domino.style.top = top - playRect.top + 'px';
          active.posr = -1; active.posc = -1;
          active.domino.style.borderColor = '#111';
        }
      }

      function onUp(ev){
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);
        document.removeEventListener('touchmove', onMove);
        document.removeEventListener('touchend', onUp);
        const clientX = ev.clientX !== undefined ? ev.clientX : (ev.changedTouches && ev.changedTouches[0].clientX);
        const clientY = ev.clientY !== undefined ? ev.clientY : (ev.changedTouches && ev.changedTouches[0].clientY);

        active.domino.style.zIndex = 2;

        const drow = (active.orientation=='vertical');
        const dcol = (active.orientation=='horizontal');
        
        if(active.oldr<0) {
          const newDomino = active.domino;

          active.domino.addEventListener('mousedown', e=>{startDominoDrag(newDomino, e.clientX, e.clientY, false)});
          active.domino.addEventListener('touchstart', e=>{
            e.preventDefault(); const t = e.touches[0];
            startDominoDrag(newDomino, t.clientX, t.clientY, false);
          });
        }

        if(active.posr<0 || covered[active.posr][active.posc] || covered[active.posr+drow][active.posc+dcol]) {
          document.getElementById('playArea').removeChild(active.domino);
          if(active.oldr>=0) { // for undos
            added.push(active);
          }
        } else {
          covered[active.posr][active.posc] = true;
          covered[active.posr+drow][active.posc+dcol] = true;
          added.push(active);
        }
        //active = null;
      }

      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
      document.addEventListener('touchmove', onMove, {passive:false});
      document.addEventListener('touchend', onUp);
    }

    dominoes.forEach(dm=>{
      dm.addEventListener('mousedown', e=>{startDominoDrag(dm, e.clientX, e.clientY, true)}); //idk why the way from the other page doesn't work here
      dm.addEventListener('touchstart', e=>{
        e.preventDefault(); const t = e.touches[0];
        startDominoDrag(dm, t.clientX, t.clientY, true);
      });
    });

    // controls
    document.getElementById('clear').addEventListener('click', ()=>{
      for(const a of added) {
        if(playArea.contains(a.domino)) {
          playArea.removeChild(a.domino);
        }
      }
      added = [];
      covered = Array(8).fill().map(()=>Array(8).fill(false));
    });
    document.getElementById('undo').addEventListener('click', ()=>{
      if(added.length<1) {
        return;
      }
      const last = added[added.length-1];

      if(last.posr>=0) {
        covered[last.posr][last.posc] = false;
        covered[last.posr+(last.orientation=='vertical')][last.posc+(last.orientation=='horizontal')] = false;
      }
      
      if(last.oldr<0) {
        playArea.removeChild(last.domino);
      } else {
        if(!playArea.contains(last.domino)) {
          playArea.appendChild(last.domino);
        }
        const b = board.getBoundingClientRect();
        const playRect = playArea.getBoundingClientRect();
        last.domino.style.left = last.oldc*b.width/8 + b.left - playRect.left-6 + 'px';
        last.domino.style.top = last.oldr*b.height/8 + b.top - playRect.top-6 + 'px';
        last.domino.style.borderColor = '#111';
        covered[last.oldr][last.oldc] = true;
        covered[last.oldr+(last.orientation=='vertical')][last.oldc+(last.orientation=='horizontal')] = true;
      }
      added.pop();
    });

    document.getElementById('check').addEventListener('click', ()=>{
      status.textContent = `You are missing ${31-added.length} domino${added.length==30?'':'es'}.`;
    });

    // accessibility: Enter to check
    document.addEventListener('keydown', e=>{ if(e.key==='Enter') document.getElementById('check').click(); });
  </script>
</body>
</html>