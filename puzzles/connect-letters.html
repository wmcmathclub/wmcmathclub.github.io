<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Connect the Matching Letters | WMC Math Club</title>
  <link rel="stylesheet" href="style.css">
  <style>

    /* ensure letters are visible above the SVG in all browsers (Edge stacking quirk) */
    svg{
        position:absolute;
        left:0;
        top:0;
        pointer-events:none;
        z-index:1
    }

    .letter{
        width:48px;
        height:40px;
        border:3px solid #111;
        background:transparent;
        display:flex;
        align-items:center;
        justify-content:center;
        position:absolute;
        font-weight:800;
        user-select:none;
        cursor:pointer;
        z-index:2
    }

    .controls{
        display:flex;
        gap:8px;
        margin-top:12px;
        align-items:center
    }

    .status{
        margin-top:8px;
        font-weight:700
    }

    .swatch{
        display:inline-block;
        width:18px;
        height:18px;
        border-radius:4px;
        margin-right:6px;
        border:2px solid #111
    }
  </style>
</head>
<body>
  <div class="card" style="position: absolute; top: 0">
    <h1>Connect matching letters without intersecting the paths.</h1>
    <p class="lead">Click a letter to start, drag freely to draw any shape, and release on the matching letter (A → A, B → B, C → C).</p>

    <div class="play">
      <div id="playArea" class="play-area" aria-label="puzzle area">
        <svg id="svg" width="100%" height="100%"></svg>
        <!-- TWO of each letter (explicit) -->
        <div class="letter" data-letter="A" id="A1" style="left:12%;top:10%;background-color:#d62728;" title="A1">A</div>
        <div class="letter" data-letter="A" id="A2" style="right:12%;top:90%;background-color:#d62728;" title="A2">A</div>
        
        <div class="letter" data-letter="B" id="B1" style="left:45%;top:0%;background-color:#118b2f" title="B1">B</div>
        <div class="letter" data-letter="B" id="B2" style="left:45%;top:90%;background-color:#118b2f" title="B2">B</div>
        
        <div class="letter" data-letter="C" id="C1" style="right:12%;top:10%;background-color:#1f77b4" title="C1">C</div>
        <div class="letter" data-letter="C" id="C2" style="left:12%;top:90%;background-color:#1f77b4" title="C2">C</div>
      </div>

      <div class="controls">
        <div class="palette">
          <span class="swatch" style="background:#d62728"></span><strong>A</strong>
          <span class="swatch" style="background:#2ca02c;margin-left:12px"></span><strong>B</strong>
          <span class="swatch" style="background:#1f77b4;margin-left:12px"></span><strong>C</strong>
        </div>

        <button id="undo">Undo</button>
        <button id="clear">Clear</button>
        <button id="check" style="background: #118b2f">Check</button>
      </div>
      <div class="status" id="status">Draw three paths connecting each pair.</div>
    </div>

    <div class="footbar">
      <div style="background:#ededed;padding:12px;border-radius:8px">
        <button id="sol_reveal">Click to reveal solution</button>
        <div id="solution" style="visibility: hidden; height: 0;">
          <h3>Solution</h3>
          <p>If you are struggling to solve a problem, a common problem-solving trick is to start with an easier problem. In this case, let's imagine that each letter was directly above its counterpart.</p>
          <img src="connect-letters-sol-1.png" style="width: 100%">
          <p>Now, we can move <b>A</b> back to its original position, 'pushing aside' the lines that it encounters.</p>
          <img src="connect-letters-sol-2.png" style="width: 100%">
          <p>Finally, we move <b>C</b> back to its original position in the same way, and now we have our solution!</p>
          <img src="connect-letters-sol-3.png" style="width: 100%">
        </div>
      <script>
        document.getElementById('sol_reveal').onclick = function(){
          const sol = document.getElementById('solution');
          sol.style.visibility = (sol.style.visibility==='visible' ? 'hidden' : 'visible');
          sol.style.height = (sol.style.visibility==='visible' ? 'auto' : '0');
          this.textContent = (sol.style.visibility==='visible' ? 'Hide solution' : 'Click to reveal solution');
        };
      </script>
        <h3>More puzzles & resources</h3>
        <p>Click below for more problems like this and math resources (Google Classroom).</p>
        <a id="moreLink" class="link" href="#">Click here for more problems like this / math resources</a>
        <button id="copyLink" style="margin-top:8px">Copy link</button>
        <small>Tip: draw smooth curves — paths can be any shape.</small>
      </div>
    </div>
  </div>

  <div class="modal" id="modal">
    <div class="box">
      <h2>Bravo!</h2>
      <p>Since you solved this, we think you'll be good at the type of problem-solving done in math club. In fact, this problem uses a branch of math called <b>Topology</b>. Want to learn more? Join math club/circle!</p>
      <p><a id="modalLink" href="#" target="_blank">Open the math club / resources</a></p>
      <p style="margin-top:12px"><button id="closeModal">Close</button></p>
    </div>
  </div>

  <script src="script.js"></script>
  <script>
    // --- CONFIG ---
    const colors = {A:'#d62728', B:'#2ca02c', C:'#1f77b4'};

    // DOM
    const svg = document.getElementById('svg');
    const letters = Array.from(document.querySelectorAll('.letter'));
    const status = document.getElementById('status');
    const moreLink = document.getElementById('moreLink');
    const modal = document.getElementById('modal');
    const modalLink = document.getElementById('modalLink');

    // store one polyline per letter (array of points) or null
    const paths = {A:null, B:null, C:null};
    let done = [];

    // helpers
    function getCenter(el){
        const r = el.getBoundingClientRect();
        const s = svg.getBoundingClientRect();
        return {x: r.left + r.width/2 - s.left, y: r.top + r.height/2 - s.top};
    }

    function redrawAll(){
        while(svg.firstChild)
            svg.removeChild(svg.firstChild);
        for(const L of ['A','B','C']){
            const poly = paths[L];
            if(!poly)
                continue;
            const el = document.createElementNS('http://www.w3.org/2000/svg','polyline');
            el.setAttribute('points', poly.map(p=>p.x+','+p.y).join(' '));
            el.setAttribute('fill','none');
            el.setAttribute('stroke', colors[L]);
            el.setAttribute('stroke-width',6);
            el.setAttribute('stroke-linecap','round');
            el.setAttribute('stroke-linejoin','round');
            svg.appendChild(el);
        }
    }

    // drawing state
    let active = null; // {letter, startEl, pts, previewEl}

    function startDrawFromElement(startEl, clientX, clientY){
      const letter = startEl.dataset.letter;
      active = {letter, startEl, pts: [ getCenter(startEl) ] };
      const preview = document.createElementNS('http://www.w3.org/2000/svg','polyline');
      preview.setAttribute('points', active.pts.map(p=>p.x+','+p.y).join(' '));
      preview.setAttribute('fill','none');
      preview.setAttribute('stroke', colors[letter]);
      preview.setAttribute('stroke-width',4);
      preview.setAttribute('stroke-linecap','round');
      preview.setAttribute('stroke-linejoin','round');
      preview.setAttribute('data-preview','1');
      svg.appendChild(preview);
      active.previewEl = preview;

      function onMove(ev){
        const clientX = ev.clientX !== undefined ? ev.clientX : (ev.touches && ev.touches[0].clientX);
        const clientY = ev.clientY !== undefined ? ev.clientY : (ev.touches && ev.touches[0].clientY);
        const s = svg.getBoundingClientRect();
        const x = Math.min(s.width,Math.max(0,clientX - s.left));
        const y = Math.min(s.height,Math.max(0,clientY - s.top));
        const last = active.pts[active.pts.length-1];
        for(const l of letters) {
          if(l.dataset.letter==active.letter)
            continue;
          const r = l.getBoundingClientRect();
          if (x+s.left >= r.left && x+s.left <= r.right && y+s.top >= r.top && y+s.top <= r.bottom) {
            onUp(ev);
            return;
          }
        }
        if(!last || Math.hypot(last.x-x,last.y-y) > 4) {
          active.pts.push({x,y});
          active.previewEl.setAttribute('points', active.pts.map(p=>p.x+','+p.y).join(' '));
        }
      }

      function onUp(ev){
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);
        document.removeEventListener('touchmove', onMove);
        document.removeEventListener('touchend', onUp);
        const clientX = ev.clientX !== undefined ? ev.clientX : (ev.changedTouches && ev.changedTouches[0].clientX);
        const clientY = ev.clientY !== undefined ? ev.clientY : (ev.changedTouches && ev.changedTouches[0].clientY);
        const targetBox = letters.find(l=>{
          const r = l.getBoundingClientRect();
          return clientX >= r.left && clientX <= r.right && clientY >= r.top && clientY <= r.bottom;
        });
        if(targetBox && targetBox !== active.startEl && targetBox.dataset.letter === active.letter){
          active.pts.push(getCenter(targetBox));
          paths[active.letter] = active.pts;
          status.textContent = `Path set for ${active.letter}.`;
          done.push(active.letter);
        }
        else {
          status.textContent = 'No valid matching target. Path discarded.';
        }
        const prev = svg.querySelector('[data-preview]');
        if(prev) prev.remove();
        active = null; redrawAll();
      }

      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
      document.addEventListener('touchmove', onMove, {passive:false});
      document.addEventListener('touchend', onUp);
    }

    letters.forEach(el=>{
      el.addEventListener('mousedown', startDrawFromElement.bind(null, el));
      el.addEventListener('touchstart', e=>{
        e.preventDefault(); const t = e.touches[0];
        startDrawFromElement(el, t.clientX, t.clientY);
      });
    });

    // intersection code for segments
    function orient(p,q,r){ return (q.x-p.x)*(r.y-p.y) - (q.y-p.y)*(r.x-p.x); }
    function segIntersect(a,b,c,d){ const o1 = orient(a,b,c), o2 = orient(a,b,d), o3 = orient(c,d,a), o4 = orient(c,d,b); if(o1===0 && o2===0 && o3===0 && o4===0) return false; return (o1*o2<0) && (o3*o4<0); }

    function pathsIntersect(){
      const segs = [];
      for(const L of ['A','B','C']){
        const poly = paths[L]; if(!poly) continue;
        for(let i=0;i<poly.length-1;i++) segs.push({a:poly[i], b:poly[i+1], letter:L});
      }
      for(let i=0;i<segs.length;i++){
        for(let j=i+1;j<segs.length;j++){
          if(segs[i].letter === segs[j].letter) continue;
          if(segIntersect(segs[i].a,segs[i].b,segs[j].a,segs[j].b)) return {intersect:true, pair:[segs[i].letter,segs[j].letter]};
        }
      }
      return {intersect:false};
    }

    // controls
    document.getElementById('clear').addEventListener('click', ()=>{
      paths.A = paths.B = paths.C = null;
      done = [];
      redrawAll();
      status.textContent='Cleared.'; 
    });
    document.getElementById('undo').addEventListener('click', ()=>{
      if(done.length<1) {
        status.textContent='Nothing to undo.';
        return;
      }

      paths[done[done.length-1]] = null;
      status.textContent=`Removed ${done[done.length-1]} path.`;
      done.pop();
      redrawAll();
      return;
    });

    document.getElementById('check').addEventListener('click', ()=>{
      if(!paths.A || !paths.B || !paths.C){ status.textContent='Please draw a path for A, B and C.'; return; }
      const intr = pathsIntersect();
      if(intr.intersect){ status.textContent = `Paths intersected between ${intr.pair[0]} and ${intr.pair[1]}. Try again.`; return; }
      status.textContent = 'No intersections detected — well done!';
      modal.classList.add('open');
    });

    document.getElementById('closeModal').addEventListener('click', ()=>{ modal.classList.remove('open'); });

    // initial render
    redrawAll();

    // accessibility: Enter to check
    document.addEventListener('keydown', e=>{ if(e.key==='Enter') document.getElementById('check').click(); });
  </script>
</body>
</html>